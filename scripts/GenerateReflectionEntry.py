#!/usr/bin/env python3
"""Generate a reflection_entry_gen.cpp that calls Describe() for every class
with PTX_BEGIN_DESCRIBE. This script attempts to produce qualified class
names (including namespaces) by locating the class/struct declaration and
scanning for enclosing namespace declarations.

Usage: generate_reflection_entry.py --root engine/include/ptx --output build/generated/reflection_entry_gen.cpp
"""
from pathlib import Path
import re
import sys

# Add scripts directory to path for consoleoutput module
SCRIPT_DIR = Path(__file__).resolve().parent
sys.path.insert(0, str(SCRIPT_DIR))

from consoleoutput import print_progress, print_status, print_section, print_warning, print_error, print_success, Colors

repo = Path(__file__).resolve().parents[1]

def find_candidates(root: Path):
    pattern = re.compile(r'PTX_BEGIN_DESCRIBE\s*\(\s*([A-Za-z_][A-Za-z0-9_:]*)\s*\)')
    candidates = []
    for p in root.rglob('*.hpp'):
        try:
            txt = p.read_text(encoding='utf-8')
        except Exception:
            continue

        # Filter out template and virtual files (same as GeneratePTXAll.py)
        if re.search(r'\btemplate\s*<', txt):
            continue
        if re.search(r'\bvirtual\b', txt):
            continue

        for m in pattern.finditer(txt):
            raw = m.group(1)
            if raw.upper() in ('CLASS', 'INTERFACE', 'STRUCT', 'ENUM'):
                continue
            candidates.append((p, raw, txt))
    return candidates


def qualify_name(raw: str, txt: str):
    # If raw already contains :: assume it's fully qualified
    if '::' in raw:
        return raw

    # Try to find a top-level declaration for the candidate and any enclosing namespaces
    candidate = raw
    # Search for a class/struct declaration for candidate
    decl_re = re.compile(r'^[ \t]*(class|struct)\s+' + re.escape(candidate) + r'\b', re.M)
    m = decl_re.search(txt)
    if not m:
        # fallback to unqualified
        return candidate

    decl_pos = m.start()

    # find enclosing class/struct declarations (for nested types like Shape::Bounds)
    enclosing_re = re.compile(r'\b(class|struct)\s+([A-Za-z_][A-Za-z0-9_]*)\b')
    last_enclosing = None
    for em in enclosing_re.finditer(txt[:decl_pos]):
        # Skip matches that are part of an 'enum class/struct' declaration.
        prefix = txt[:em.start()].rstrip()
        m_prev = re.search(r'([A-Za-z_][A-Za-z0-9_]*)$', prefix)
        if m_prev and m_prev.group(1) == 'enum':
            continue
        last_enclosing = em
    if last_enclosing:
        # ensure the enclosing declaration actually opens a '{' before decl_pos
        part = txt[last_enclosing.end():decl_pos]
        opens = part.count('{')
        closes = part.count('}')
        if opens > closes:
            parent = last_enclosing.group(2)
            # Heuristic: detect whether the nested declaration lives in a private
            # section of the parent by looking for the last 'public:'/'private:'
            # labels between the parent start and the nested declaration.
            section_span = txt[last_enclosing.end():decl_pos]
            last_public = section_span.rfind('public:')
            last_private = section_span.rfind('private:')
            if last_private > last_public:
                # nested type is private; skip emitting a call (can't access)
                return None
            return f"{parent}::{candidate}"

    # fallback: try to detect enclosing namespaces
    ns_re = re.compile(r'(?<!@)\bnamespace\s+([A-Za-z_][A-Za-z0-9_:]*)')
    namespaces = []
    for nm in ns_re.finditer(txt[:decl_pos]):
        brace_idx = txt.find('{', nm.end())
        if brace_idx != -1 and brace_idx < decl_pos:
            part = txt[nm.end():decl_pos]
            if part.count('{') > part.count('}'):
                for seg in nm.group(1).split('::'):
                    if seg:
                        namespaces.append(seg)

    if namespaces:
        qualified = '::'.join(namespaces + [candidate])
        return qualified

    return candidate


def build_class_list(root: Path):
    candidates = find_candidates(root)
    class_names = set()
    for path, raw, txt in candidates:
        q = qualify_name(raw, txt)
        if q:
            class_names.add(q)
    return sorted(class_names)


def write_output(out: Path, classes):
    out.parent.mkdir(parents=True, exist_ok=True)
    with out.open('w', encoding='utf-8') as fp:
        fp.write('// Auto-generated registry translation unit (generated by scripts/generate_reflection_entry.py)\n')
        fp.write('#include <ptx/ptxall.hpp>\n\n')
        fp.write('namespace { struct _AutoDescribe { _AutoDescribe() {\n')
        for c in classes:
            fp.write(f'    (void){c}::Describe();\n')
        fp.write('} }; static _AutoDescribe _auto_describe_instance; }\n')
    print_success(f'   Wrote {out} with {len(classes)} Describe() calls')


def main():
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument('--root', required=True)
    ap.add_argument('--output', required=True)
    ns = ap.parse_args()
    root = Path(ns.root)
    out = Path(ns.output)

    print_section("Generating reflection entry file...")
    print_status(f"   Scanning: {root}", Colors.GREEN)

    classes = build_class_list(root)
    if not classes:
        print_warning('No classes found (no PTX_BEGIN_DESCRIBE)')
        sys.exit(0)

    write_output(out, classes)


if __name__ == '__main__':
    main()
